setwd("~/Development/bads-challenge")
load("~/Development/bads-challenge/.RData")
head(cats$LAST_SWAP)
cats$LAST_SWAP
table(cats$REFURB_NEW,cats$CHURN)
cats <- x[,names(x) %in% categorical_features]
x <- dataset
categorical_features <- c("ACTVSUBS","ADULTS","AGE1","AGE2","AREA","ASL_FLAG","CAR_BUY","CARTYPE","CHILDREN","CHURN","CRCLSCOD","CREDITCD","CRTCOUNT","CSA","CUSTOMER_ID","DIV_TYPE","DUALBAND","DWLLSIZE","DWLLTYPE","EDUC1","ETHNIC","FORGNTVL","HND_PRICE","HHSTATIN","HND_WEBCAP","INCOME","INFOBASE","KID0_2","KID3_5","KID6_10","KID11_15","KID16_17","LAST_SWAP","LOR","MAILFLAG","MAILORDR","MAILRESP","MARITAL","MODELS","MTRCYCLE","NEW_CELL","NUMBCARS","OCCU1","OWNRENT","PCOWNER","PHONES","PRE_HND_PRICE","PRIZM_SOCIAL_ONE","PROPTYPE","REF_QTY","REFURB_NEW","RV","SOLFLAG","TOT_ACPT","TOT_RET","TRUCK","UNIQSUBS","WRKWOMAN")
cats <- x[,names(x) %in% categorical_features]
cats$ACTIVESUBS <- as.numeric(cats$ACTVSUBS)
cats$SPENDING_LIMIT <- 0
cats[cats$ASL_FLAG=="Y",]$SPENDING_LIMIT <- 1
# Dummyfy new car
cats$NEW_CAR<- 0
cats[cats$CAR_BUY=="New",]$NEW_CAR <- 1
# Dummyfy credit class
cats$GOOD_CREDIT_SCORE <- 0
cats[cats$CRCLSCOD  %in% c("A","A2","AA","B","B2","BA"),]$GOOD_CREDIT_SCORE <- 1
cats$BAD_CREDIT_SCORE <- 0
cats[cats$CRCLSCOD  %in% c("Z1","Z2","Z3","Z4","Z5","ZA","ZB","ZF","ZY","ZZ"),]$BAD_CREDIT_SCORE <- 1
# Dummyfy credit card indicator
cats$HAS_CREDIT_CARD <- 0
cats[cats$CREDITCD=="Yes",]$HAS_CREDIT_CARD <- 1
View(cats)
summary(cats$CREDITCD)
str(cats$CREDITCD)
cats[cats$CREDITCD=="Y",]$HAS_CREDIT_CARD <- 1
# make numerical out of adjustment made to credit rating
cats[is.na(cats$CRTCOUNT),]$CRTCOUNT <- 0
cats$CREDIT_ADJUSTED <- as.numeric(cats$CRTCOUNT)
# Dummyfy additional services
cats$LONG_DISTANCE_SERVICE <- 0
cats$LOCAL_PHONE_SERVICE <- 0
cats[cats$DIV_TYPE=="LDD",]$LONG_DISTANCE_SERVICE <- 1
cats[cats$DIV_TYPE=="BTH",]$LONG_DISTANCE_SERVICE <- 1
cats[cats$DIV_TYPE=="LTD",]$LOCAL_PHONE_SERVICE <- 1
cats[cats$DIV_TYPE=="BTH",]$LOCAL_PHONE_SERVICE <- 1
# Dummyfy dualband
cats$DB <- 0
cats[cats$DUALBAND=="Y",]$DB <- 1
cats[cats$DUALBAND=="T",]$DB <- 1
# dummyfy foreign travel
cats$FOREIGN_TRAVEL <- 0
cats[cats$FORGNTVL == 1]$FOREIGN_TRAVEL <- 1
str(cats$FORGNTVL)
cats[cats$FORGNTVL == 1,]$FOREIGN_TRAVEL <- 1
# Convert current handset price to numerical
cats$CURRENT_PHONE_PRICE <- as.numeric(cats$HND_PRICE)
cats[is.na(cats$CURRENT_PHONE_PRICE),]$CURRENT_PHONE_PRICE <- median(cats$CURRENT_PHONE_PRICE, na.rm = TRUE)
# Dummy db information about customer
cats$FULL_INFORMATION <- 0
cats[cats$HHSTATIN=="C",]$FULL_INFORMATION <- 1
cats[cats$HHSTATIN=="I",]$FULL_INFORMATION <- 1
# Convert estimated income to numerical
cats$ESTIMATED_INCOME <- as.numeric(cats$INCOME)
cats[is.na(cats$ESTIMATED_INCOME),]$ESTIMATED_INCOME<- median(cats$ESTIMATED_INCOME, na.rm = TRUE)
# Get the years of the last swapped variable
substrRight <- function(x, n){
substr(x, nchar(x)-n+1, nchar(x))
}
years <- substrRight(cats$LAST_SWAP,4)
cats$LAST_PHONE_SWAP = 0
cats[years=="1999",]$LAST_PHONE_SWAP<- 2
cats[years=="2000",]$LAST_PHONE_SWAP<- 1
# dummyfy do not mail flag
cats$DO_NOT_MAIL <- 0
cats[cats$MAILFLAG=="Y",]$DO_NOT_MAIL <- 1
# dummyfy mail responder
cats$RESPOND_TO_MAIL <- 0
cats[cats$MAILRESP=="R",]$RESPOND_TO_MAIL <- 1
# Make number of models numeric
cats$MODELS_ISSUED <- as.numeric(cats$MODELS)
# make binary for mobile home owners
cats$OWNS_MOBILE_HOME <- 0
cats[cats$PROPTYPE=="M"]$OWNS_MOBILE_HOME <- 1
# make number of referrals numeric
cats[cats$PROPTYPE=="M",]$OWNS_MOBILE_HOME <- 1
# make number of referrals numeric
cats[is.na(cats$REF_QTY),]$REF_QTY <- 0
cats$REF_QTY_NUM <- as.numeric(cats$REF_QTY)
str(cats$REF_QTY_NUM)
str(as.factor(cats$REF_QTY_NUM))
cats$REFURBISHED <- 0
cats[cats$REFURB_NEW=="R",]$REFURBISHED <- 1
# dummyfy RV
cats$OWNS_RV <- 0
cats[cats$RV==1]$OWNS_RV <- 1
# dummyfy do not solicit
cats$DO_NOT_SOLICIT <- 0
cats[cats$RV==1,]$OWNS_RV <- 1
cats$OWNS_RV <- 0
cats[cats$RV==1,]$OWNS_RV <- 1
str(as.factor(cats$RV))
cats$OWNS_RV <- 0
cats[cats$RV==1,]$OWNS_RV <- 1
cats$DO_NOT_SOLICIT <- 0
cats[cats$SOLFLAG=="N",]$DO_NOT_SOLICIT <- 1
# encode if they have received and declined offers from retention team
cats$RECEIVED_OFFER <- 1
cats[is.na(cats$TOT_ACPT),] <- 0
cats$RECEIVED_OFFER <- 1
cats[is.na(cats$TOT_ACPT),]$RECEIVED_OFFER <- 0
length(is.na(cats$TOT_ACPT))
which(length(is.na(cats$TOT_ACPT)))
length(is.na(cats$TOT_ACPT) == TRUE)
cats$DECLINED_OFFER <- 0
cats[cats$TOT_ACPT==0,] <- 1
cats[cats$TOT_ACPT==0,]$DECLINED_OFFER <- 1
cats$NUMBER_OF_RETENTION_CALLS <- as.numeric(cats$TOT_RET)
cats[is.na(cats$TOT_RET),]$NUMBER_OF_RETENTION_CALLS <- 0
cats$NUMBER_OF_SUBS <- as.numeric(cats$UNIQSUBS)
str(as.factor(cats$RECEIVED_OFFER))
summary(as.factor(is.na(cats$TOT_ACPT)))
str(as.factor(cats$TOT_ACPT))
str(as.factor(dataset$TOT_ACPT))
cats <- x[,names(x) %in% categorical_features]
cats$DO_NOT_SOLICIT <- 0
cats[cats$SOLFLAG=="N",]$DO_NOT_SOLICIT <- 1
cats$RECEIVED_OFFER <- 1
cats[is.na(cats$TOT_ACPT),]$RECEIVED_OFFER <- 0
cats$DECLINED_OFFER <- 0
cats[cats$TOT_ACPT==0,]$DECLINED_OFFER <- 1
cats$NUMBER_OF_OFFERS <- 0
cats[cats$RECEIVED_OFFER==1,]$NUMBER_OF_OFFERS <- cats$TOT_ACPT
str(as.factor(cats$RECEIVED_OFFER))
summary(as.factor(cats$DECLINED_OFFER))
summary(as.factor(cats$RECEIVED_OFFER))
cats[is.na(cats$TOT_ACPT),] <- 99
cats[is.na(cats$TOT_ACPT),]$TOT_ACPI <- 99
cats <- x[,names(x) %in% categorical_features]
cats[is.na(cats$TOT_ACPT),]$TOT_ACPI <- 99
cats[is.na(cats$TOT_ACPT),]$TOT_ACPT <- 99
cats$DECLINED_OFFER <- 0
cats[cats$TOT_ACPT==0,]$DECLINED_OFFER <- 1
cats$NUMBER_OF_OFFERS <- 0
cats[cats$RECEIVED_OFFER==1,]$NUMBER_OF_OFFERS <- cats$TOT_ACPT
cats$TOT_ACPT <- as.numeric(cats$TOT_ACPT)
cats[cats$RECEIVED_OFFER==1,]$NUMBER_OF_OFFERS <- cats$TOT_ACPT
# make numerical the number of retention calls they have received
cats$NUMBER_OF_RETENTION_CALLS <- as.numeric(cats$TOT_RET)
cats[is.na(cats$TOT_RET),]$NUMBER_OF_RETENTION_CALLS <- 0
# make numerical the number of subs they have
cats$NUMBER_OF_SUBS <- as.numeric(cats$UNIQSUBS)
cats$NUMBER_OF_OFFERS <- ifelse(cats$RECEIVED_OFFER==1,cats$TOT_ACPT,0)
cats$RECEIVED_OFFER <- 1
cats[is.na(cats$TOT_ACPT),]$RECEIVED_OFFER <- 0
cats[cats$TOT_ACPT==99,]$RECEIVED_OFFER <- 0
cats$NUMBER_OF_OFFERS <- ifelse(cats$RECEIVED_OFFER==1,cats$TOT_ACPT,0)
cats$OWNS_RV <- ifelse(!is.na(cats$RV) & cats$RV==1 , 1 , 0)
churn <- cats$CHURN
id <- cats$CUSTOMER_ID
cats <- cats[,!name(cats %in% categorical_features)]
cats <- cats[,!names(cats %in% categorical_features)]
cats <- cats[,!names(cats) %in% categorical_features]
source("prep/encodeData.R")
source("encodeData.R")
source("encodeFeatures.R")
dataset <- encodeFeatures(dataset)
source("encodeFeatures.R")
dataset <- encodeFeatures(dataset)
x <- dataset
x[,names(x) %in% numerical_features] <- apply(x[,names(x) %in% numerical_features],2,as.numeric)
str(x)
source("encodeFeatures.R")
dataset <- encodeFeatures(dataset)
dataset <- encodeFeatures(dataset)
source("encodeFeatures.R")
dataset <- encodeFeatures(dataset)
dataset <- encodeFeatures(dataset)
source("encodeFeatures.R")
dataset <- encodeFeatures(dataset)
# save ids for later
ids <- dataset$id
# Impute data with median!
dataset.imputed <- dataset[,!names(dataset)%in% c("id")]
imputeMedian <- function(x){
miss <- is.na(x)
x[miss] <- median(x,na.rm = T)
return(x)
}
any(is.na(dataset.imputed))
for (i in 1:length(dataset.imputed)) {
if(is.numeric(dataset.imputed[,i])){
dataset.imputed[,i] <- imputeMedian(dataset.imputed[,i])
}
}
any(is.na(dataset.imputed))
source("performance.R")
View(dataset)
View(dataset.imputed)
View(dataset.imputed[90:144])
dataset.imputed$churn <- factor(dataset.imputed$churn,levels=c(0,1),labels=c("stay","leave"))
library("caret", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
library("pROC", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
set.seed(800)
index <- c(1:nrow(dataset.imputed))
trainingData <- sample(index,round(nrow(dataset.imputed))*0.8)
test <- dataset.imputed[-trainingData,]
training <- dataset.imputed[trainingData,]
delete(trainingData)
remove(trainingData)
fitControl <- trainControl(## 5-fold CV
method = "cv",
number = 5,
allowParallel=T,
summaryFunction = twoClassSummary,
classProbs = TRUE)
xgb.grid <- expand.grid(nrounds = c(250,500),
eta = c(0.01,0.03,0.05),
max_depth = c(2,4,6),
colsample_bytree = c(0.8,1),
min_child_weight = 1,
gamma=0
)
xgb.optimal <- expand.grid(nrounds = 500,
eta = 0.01,
max_depth = 4,
colsample_bytree = 0.9,
min_child_weight = 1,
gamma=0
)
xgbFit <- train(churn ~ ., data = training,
method = "xgbTree",
trControl = fitControl,
tuneGrid= xgb.grid,
verbose=TRUE,
metric="ROC"
)
pred.xgb.prob <- predict(xgbFit,test, type="prob")["leave"]
pred.xgb.binary <- predict(xgbFit,test)
cm.xgb <- confusionMatrix(pred.xgb.binary,test$churn,positive = "leave")
# Performance Metrics
performance(pred.xgb.prob,test$churn)
cm.xgb
xgbFit
lift.custom <- function(preds,actual){
combine <- data.frame(actual,preds)
names(combine) <- c("Actual","Pred")
combine <- combine[with(combine, order(-Pred)),]
combine.ten <- combine[1:(nrow(combine)*0.1),]
hits <- nrow(combine.ten[combine.ten$Actual=="leave",])
right.per <- hits/(nrow(combine.ten))
right.per <- right.per*100
actuals <- nrow(combine[combine$Actual=="leave",])
actuals.per <- (actuals/nrow(combine) )* 100
return(right.per/actuals.per)
}
performance(pred.xgb.prob,test$churn)
varImp(xgbFit)
varImp(xgbFit, top=50)
?varImp
sub <- predict(xgbFit,dataset.imputed, type="prob")["leave"]
x <- data.frame(Customer_ID=ids,EstimatedChurnProbability=sub$leave)
write.table(x,"submis.csv",sep=",",row.names=FALSE)
